name: Security Framework Gates

on:
  push:
    branches: ["main", "release/*"]
    tags: ["v*"]
  pull_request:
    branches: ["main", "release/*"]
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      tamper_sbom:
        description: "Tamper artifact AFTER SBOM?"
        required: false
        type: boolean
        default: false
  schedule:
    - cron: "0 */6 * * *"



concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write
  packages: read
  id-token: write
  attestations: write

env:
  ENFORCEMENT: warn
  CAN_ATTEST: ${{ (github.event_name == 'push') || (github.event_name == 'workflow_dispatch') || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) }}

jobs:
 
  no_floating_images:
    name: M2 — forbid ':latest' and unpinned base images
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Fail on floating Docker base images
        shell: bash
        run: |
          set -euo pipefail
          # put together a list Dockerfile's
          mapfile -t DF < <(git ls-files | grep -Ei '(^|/)(Dockerfile|.*\.Dockerfile)$' || true)
          [ ${#DF[@]} -gt 0 ] || { echo "No Dockerfiles found"; exit 0; }

          bad=0
          echo "Checking Dockerfiles:"
          for f in "${DF[@]}"; do
            echo "  - $f"
            # extract lines FROM 
            while IFS= read -r line; do
              img=$(sed -E 's/^[[:space:]]*FROM[[:space:]]+//I; s/[[:space:]]+AS.*$//I' <<<"$line")
              # rules:
              # 1) prohibited ':latest'
              # 2) prohibited without tag And without @sha256 (т.е. must be either tag, either digest)
              if grep -Eq ':[[:alnum:]_.-]+(@sha256:[0-9a-f]{64})?$' <<<"$img"; then
                tag="${img##*:}"
                if [[ "$tag" == "latest" ]]; then
                  echo "::error file=$f::FROM uses ':latest' → $line"
                  bad=1
                fi
              elif grep -Eq '@sha256:[0-9a-f]{64}$' <<<"$img"; then
                : # ok — pin by digest
              else
                echo "::error file=$f::FROM without explicit tag or digest → $line"
                bad=1
              fi
            done < <(grep -Ei '^[[:space:]]*FROM[[:space:]]+' "$f" | grep -Ev '^[[:space:]]*#')
          done

          if [ $bad -ne 0 ]; then
            echo "ERROR: Floating base images detected"; exit 1
          fi
          echo "All Dockerfiles pinned ✅"

   
  
  
  
  # ---------------- SAST / SCA presence ----------------
  codeql:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - uses: github/codeql-action/init@192325c86100d080feab897ff886c34abd4c83a3
        with:
          languages: actions, python
      - uses: github/codeql-action/analyze@192325c86100d080feab897ff886c34abd4c83a3

  dependency_review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Compute base/head refs
        id: deprefs
        shell: bash
        run: |
          set -euo pipefail
          HEAD_SHA="${GITHUB_SHA}"
          if [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            BEFORE="$(jq -r .before "$GITHUB_EVENT_PATH")"
            if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
              echo "base=$BEFORE" >> "$GITHUB_OUTPUT"
            else
              git fetch --no-tags --prune --depth=2 origin "${GITHUB_REF}"
              echo "base=$(git rev-parse "${HEAD_SHA}^" 2>/dev/null || echo '')" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "base=$(jq -r .pull_request.base.sha "$GITHUB_EVENT_PATH")" >> "$GITHUB_OUTPUT"
          fi
      - uses: actions/dependency-review-action@595b5aeba73380359d98a5e087f648dbb0edce1b
        if: steps.deprefs.outputs.base != ''
        with:
          base-ref: ${{ steps.deprefs.outputs.base }}
          head-ref: ${{ github.sha }}
          fail-on-severity: critical
        continue-on-error: true

  # --------------- Verify action publishers (allow-list + pin) ---------------
  verify_action_publishers:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Verify publishers + pin to commit (WARN only)
        env:
          GH_TOKEN: ${{ github.token }}
          ALLOW_OWNERS: actions|github|aws-actions|google-github-actions|dependabot|azure
          YQ_VER: ${{ vars.YQ_VERSION }}
          YQ_SHA512: ${{ vars.YQ_SHA512 }}
        shell: bash
        run: |
          set -euo pipefail
          YQ_VERSION="${YQ_VER:-v4.44.3}"
          if [ -n "${YQ_SHA512:-}" ]; then
            sudo curl -fsSL -L -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
            echo "${YQ_SHA512}  /usr/local/bin/yq" | sha512sum -c -
            sudo chmod +x /usr/local/bin/yq
          else
            sudo curl -fsSL -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
            sudo chmod +x /usr/local/bin/yq
            echo "::warning::YQ_SHA512 repo variable not set — checksum for yq not verified"
          fi

          status=0
          mapfile -t WF < <(git ls-files '.github/workflows/*.y*ml' 2>/dev/null || true)
          for f in "${WF[@]}"; do
            while read -r line; do
              u="${line#uses: }"
              owner=$(echo "$u" | awk -F'[/:@]' '{print $1}')
              sha=$(echo "$u" | awk -F'@' '{print $2}')
              if ! [[ "$owner" =~ ^(${ALLOW_OWNERS})$ ]]; then
                echo "::error file=$f::owner '$owner' is not allowed by enterprise policy"
                status=1
              fi
              if ! [[ "$sha" =~ ^[0-9a-f]{40}$ ]]; then
                echo "::error file=$f::'$u' is NOT pinned to full 40-char commit SHA"
                status=1
              fi
            done < <(yq -r '.. | .uses? | select(type=="string") | "uses: "+.' "$f")
          done

          if [ $status -ne 0 ]; then
            echo "::warning::violations found in uses:, but ENFORCEMENT=WARN → not failing"
            exit 0
          fi

  # ---------------- Build + SBOM + Attest ----------------
  build_and_attest:
    needs: [codeql, dependency_review, verify_action_publishers]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      attestations: write
      id-token: write
    env:
      GH_TOKEN: ${{ github.token }}
      SYFT_VER: ${{ vars.SYFT_VERSION }}
      SYFT_TGZ_SHA256: ${{ vars.SYFT_TGZ_SHA256 }}
    steps:
      - name: (light) egress log
        shell: bash
        run: |
          echo "Open connections BEFORE:"; ss -tpn || true

      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Build artifact
        run: |
          echo "hello $(date -u +%FT%TZ)" > artifact.txt
          sha256sum artifact.txt | tee checksums.txt 
      - name: Export SBOM (Syft)
        shell: bash
        run: |
          set -euo pipefail
          VER="${SYFT_VER:-v1.33.0}"
          curl -fsSL -o syft.tgz "https://github.com/anchore/syft/releases/download/${VER}/syft_${VER#v}_linux_amd64.tar.gz" || \
          curl -fsSL -o syft.tgz "https://github.com/anchore/syft/releases/download/${VER}/syft_Linux_x86_64.tar.gz"
          if [ -n "${SYFT_TGZ_SHA256:-}" ]; then
            echo "${SYFT_TGZ_SHA256}  syft.tgz" | sha256sum -c -
          else
            echo "::warning::SYFT_TGZ_SHA256 repo variable not set — checksum for syft.tgz not verified"
          fi
          tar -xzf syft.tgz syft && sudo install -m0755 syft /usr/local/bin/syft
          syft "file:artifact.txt" -o spdx-json=sbom.spdx.json
          D=$(sha256sum artifact.txt | awk '{print $1}')
          jq --arg d "$D" '.files=((.files // [])|map(select(.fileName!="artifact.txt")))+
             [{"fileName":"artifact.txt","SPDXID":"SPDXRef-File-artifact.txt","checksums":[{"algorithm":"SHA256","checksumValue":$d}]}]' \
             sbom.spdx.json > t && mv t sbom.spdx.json

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: build
          path: |
            artifact.txt
            checksums.txt
            sbom.spdx.json

      - name: Attest provenance
        if: env.CAN_ATTEST == 'true'
        uses: actions/attest-build-provenance@ef244123eb79f2f7a7e75d99086184180e6d0018
        with:
          subject-path: artifact.txt

      - name: Attest SBOM
        if: env.CAN_ATTEST == 'true'
        uses: actions/attest-sbom@5026d3663739160db546203eeaffa6aa1c51a4d6
        with:
          subject-path: artifact.txt
          sbom-path: sbom.spdx.json

      - name: Verify attestations
        if: env.CAN_ATTEST == 'true'
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          set -euo pipefail
          if ! gh attestation --help >/dev/null 2>&1; then
            gh extension install github/gh-attestation
          fi
          WF="${GITHUB_WORKFLOW_REF}"
          REPO="${GITHUB_REPOSITORY}"
          successes=0; failures=0
          for PT in "https://slsa.dev/provenance/v1" "https://spdx.dev/Document"; do
            verified=0
            for i in $(seq 1 8); do
              if gh attestation verify artifact.txt \
                    --repo "${REPO}" \
                    --predicate-type "${PT}" \
                    --cert-oidc-issuer "https://token.actions.githubusercontent.com" \
                    --signer-workflow "${WF}" \
                    --deny-self-hosted-runners --limit 50; then
                verified=1; break; fi
              sleep 10
            done
            if [ $verified -eq 1 ]; then successes=$((successes+1)); else failures=$((failures+1)); fi
          done
          [ $failures -eq 0 ] || true  # WARN-only

  tamper_after_sbom:
    name: "⚠️ tamper_after_sbom"
    needs: [build_and_attest]
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tamper_sbom == 'true') }}
    steps:
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build

      - name: Tamper artifact AFTER SBOM
        shell: bash
        run: |
          set -euo pipefail
          printf '\nTAMPERED %s\n' "$(date -u +%FT%TZ)" >> artifact.txt
          sha256sum artifact.txt | tee checksums.txt

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: build
          path: |
            artifact.txt
            checksums.txt
            sbom.spdx.json
          overwrite: true

  
  
  
  
  
  # ---------------- Trust-store (JWKS / allowed_signers / revocations) ----------------
  trust_store_guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Load org trust-store (if set)
        id: t
        shell: bash
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          SRC=""
          if [ -n "${ORG_TRUST_REPO:-}" ]; then
            echo "Trying to clone org trust repo: ${ORG_TRUST_REPO}"
            if gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
              if [ -d _orgtrust/.github/trust ]; then
                cp -a _orgtrust/.github/trust/. .github/trust/
                SRC="org:${ORG_TRUST_REPO}"
              fi
            else
              echo "::notice::gh clone failed (private repo or GH_TOKEN missing?)"
            fi
          fi
          if [ -z "$SRC" ] && [ -d ".github/trust" ] && [ -f ".github/trust/publishers.jwks.json" ]; then
            SRC="local:.github/trust (already present)"
          fi
          echo "source=${SRC:-none}" >> "$GITHUB_OUTPUT"
          echo "Resolved trust-store source: ${SRC:-none}"
          ls -la .github/trust || true

      - name: Validate trust-store files
        env:
          AWS_KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          test -f .github/trust/publishers.jwks.json || { echo "::error::JWKS missing (.github/trust/publishers.jwks.json)"; exit 1; }
          jq -e '.keys|length>0' .github/trust/publishers.jwks.json >/dev/null
          test -f .github/trust/allowed_signers.json || { echo "::error::allowed_signers.json missing"; exit 1; }
          test -f .github/trust/revocations.json || { echo "::group::revocations.json missing -> treat as empty"; echo '{"kids":[]}' > .github/trust/revocations.json; echo "::endgroup::"; }
          if [ -n "${AWS_KMS_KEY_ID:-}" ]; then
            K="AWS:${AWS_KMS_KEY_ID}"
            jq -r '.keys[].kid' .github/trust/publishers.jwks.json | grep -Fx "$K" >/dev/null || {
              echo "::warning::KID mismatch (expected $K)"; true; }
          fi
          echo "Trust-store ready:"
          ls -l .github/trust
          jq -r '.keys[].kid' .github/trust/publishers.jwks.json

  # ---------------- Access recertification gate (BLOCK on expiry) ----------------
  access_recert_gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Block if any group recert is expired
        shell: bash
        run: |
          set -euo pipefail
          test -f .github/trust/access_catalog.json || { echo "::error::missing .github/trust/access_catalog.json"; exit 1; }
          NOW=$(date -u +%F)
          EXPIRED=$(jq -r --arg NOW "$NOW" '.groups[] | select(.recert_expires_at < $NOW) | .name' .github/trust/access_catalog.json)
          if [ -n "$EXPIRED" ]; then
            echo "::error::Access recert expired for groups:"; echo "$EXPIRED" | sed 's/^/- /'
            exit 1
          fi
          echo "Access recert OK as of $NOW"

  # ---------------- KMS sign + verify ----------------
  kms_sign_and_verify:
    needs: [build_and_attest, trust_store_guard]
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      id-token: write
      contents: read
    steps:
      - name: (light) egress log
        shell: bash
        run: |
          echo "Open connections BEFORE:"; ss -tpn || true

      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Decide if AWS steps are allowed for this ref
        id: gate
        shell: bash
        run: |
          case "${GITHUB_REF}" in
            refs/heads/main|refs/heads/release/*|refs/tags/v*) echo "aws=yes"  >> "$GITHUB_OUTPUT" ;;
            *)                                               echo "aws=no"   >> "$GITHUB_OUTPUT" ;;
          esac

      - name: Load org trust-store (for this job too)
        if: steps.gate.outputs.aws == 'yes'
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          if [ -n "${ORG_TRUST_REPO:-}" ] && gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
            test -d _orgtrust/.github/trust && cp -a _orgtrust/.github/trust/. .github/trust/ || true
          fi
          ls -la .github/trust || true

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build

      - name: Configure AWS (OIDC assume role)
        if: steps.gate.outputs.aws == 'yes'
        uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
          audience: sts.amazonaws.com
          role-session-name: gha-${{ github.run_id }}-${{ github.run_attempt }}

      - name: KMS Sign artifact.txt (PS256)
        if: steps.gate.outputs.aws == 'yes'
        run: |
          set -euo pipefail
          aws kms sign --key-id "${{ vars.AWS_KMS_KEY_ID }}" \
            --signing-algorithm RSASSA_PSS_SHA_256 --message-type RAW \
            --message fileb://artifact.txt --query Signature --output text | base64 -d > artifact.sig

      - name: Fetch public key & verify
        if: steps.gate.outputs.aws == 'yes'
        run: |
          set -euo pipefail
          aws kms get-public-key --key-id "${{ vars.AWS_KMS_KEY_ID }}" \
            --query PublicKey --output text | base64 -d > aws-pub.der
          openssl pkey -pubin -inform DER -in aws-pub.der -out aws-pub.pem
          openssl dgst -sha256 -verify aws-pub.pem -signature artifact.sig \
            -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:digest -sigopt rsa_mgf1_md:sha256 artifact.txt

      - name: AWS steps skipped for this ref
        if: steps.gate.outputs.aws != 'yes'
        run: echo "::notice::Skipping AWS assume/sign (ref '${GITHUB_REF}' is not main/release/*/tags v*)"

      - name: Trust-store check for signer (warn)
        if: steps.gate.outputs.aws == 'yes'
        shell: bash
        env:
          KID: AWS:${{ vars.AWS_KMS_KEY_ID }}
          ENF: ${{ env.ENFORCEMENT }}
        run: |
          set -euo pipefail
          ok=0
          test -f .github/trust/publishers.jwks.json && \
            jq -e --arg k "$KID" '.keys[]?|.kid==$k' .github/trust/publishers.jwks.json >/dev/null && ok=1
          revoked=0
          test -f .github/trust/revocations.json && \
            jq -e --arg k "$KID" '.kids[]?|.==$k' .github/trust/revocations.json >/dev/null && revoked=1 || true
          if [ $ok -ne 1 ]; then
            echo "::warning::Signer $KID is NOT in publishers.jwks.json"; true; fi
          if [ $revoked -eq 1 ]; then
            echo "::warning::Signer $KID is REVOKED in revocations.json"; true; fi

      - name: Save signing evidence
        if: steps.gate.outputs.aws == 'yes'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: signing-evidence
          path: |
            artifact.txt
            artifact.sig
            aws-pub.pem
            checksums.txt

  # ---------------- SBOM enforce ----------------
  sbom_enforce:
    needs: [build_and_attest, tamper_after_sbom]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build
      - name: Enforce SBOM digest (FAIL on mismatch)
        shell: bash
        run: |
          set -euo pipefail
          A=$(sha256sum artifact.txt | awk '{print $1}')
          S=$(jq -r '.files[]?|select(.fileName=="artifact.txt")|.checksums[]?|select(.algorithm=="SHA256")|.checksumValue' sbom.spdx.json | head -n1)
          if [ -z "$S" ] || [ "$A" != "$S" ]; then
            echo "::error::SBOM mismatch/missing (artifact=$A, sbom=${S:-<none>})"
            exit 1
          fi
          echo "SBOM OK"




  # ---------------- Secrets presence gate ----------------
  secrets_presence_gate:
    needs: [build_and_attest]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Scan repo & workflows for secrets (heuristic)
        id: repo_scan
        shell: bash
        run: |
          set -euo pipefail
          PATTERN='AKIA|ASIA|ghp_[A-Za-z0-9]{36,}|github_pat_[A-Za-z0-9_]{82,}|xox[abrs]-|BEGIN (RSA |OPENSSH )?PRIVATE KEY|SECRET_ACCESS_KEY|token=|password='
          found=0
          grep -RInE "$PATTERN" -- . --exclude-dir=.git || true
          [ ${PIPESTATUS[0]} -eq 0 ] && found=1
          if [ -d .github/workflows ]; then
            grep -RInE "$PATTERN" -- .github/workflows --exclude-dir=.git || true
            [ ${PIPESTATUS[0]} -eq 0 ] && found=1
          fi
          echo "found=$found" >> "$GITHUB_OUTPUT"
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          path: _scan/artifacts
          merge-multiple: true
        continue-on-error: true
      - name: Scan artifacts for secrets (if present)
        id: art_scan
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d "_scan/artifacts" ] || ! ls -A _scan/artifacts >/dev/null 2>&1; then
            echo "::warning::no build artifacts to scan (skipping)"
            echo "found=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          PATTERN='AKIA|ASIA|ghp_[A-Za-z0-9]{36,}|github_pat_[A-Za-z0-9_]{82,}|xox[abrs]-|BEGIN (RSA |OPENSSH )? PRIVATE KEY|SECRET_ACCESS_KEY|token=|password='
          if grep -RInE --binary-files=without-match --exclude-dir=.git --exclude-dir=.github "$PATTERN" _scan/artifacts ; then
            echo "::warning::possible secrets found in build artifacts"
            echo "found=1" >> "$GITHUB_OUTPUT"
          else
            echo "found=0" >> "$GITHUB_OUTPUT"
          fi
      - name: Write secrets scan report (repo + artifacts)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p _reports
          {
            echo "# Secrets scan (repo/workflows)"
            PATTERN='AKIA|ASIA|ghp_[A-Za-z0-9]{36,}|github_pat_[A-Za-z0-9_]{82,}|xox[abrs]-|BEGIN (RSA |OPENSSH )?PRIVATE KEY|SECRET_ACCESS_KEY|token=|password='
            grep -RInE "$PATTERN" -- . --exclude-dir=.git || true
            echo
            echo "# Secrets scan (artifacts)"
            if [ -d "_scan/artifacts" ] && ls -A _scan/artifacts >/dev/null 2>&1; then
              grep -RInE --binary-files=without-match --exclude-dir=.git --exclude-dir=.github "$PATTERN" _scan/artifacts || true
            else
              echo "no artifacts to scan"
            fi
          } > _reports/secrets_scan.txt
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: security-reports
          path: _reports/secrets_scan.txt
          if-no-files-found: ignore

  # ---------------- Permissions gate ----------------
  permissions_gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Lint permissions (deny dangerous writes)
        run: |
          set -euo pipefail
          bad=$(grep -RInE 'permissions:\s*(write-all|{[^}]*: *write[^}]*})' .github/workflows || true)
          if [ -n "$bad" ]; then
            echo "$bad"
            echo "::warning::dangerous token permissions found"; true
          else
            echo "permissions OK"
          fi
      - name: Deny interactive signing patterns
        shell: bash
        run: |
          set -euo pipefail
          bad=$(grep -RInE '\bgpg(\.exe)?\b.*\b(--sign|-s)\b|openssl .* -passin +(pass:|env:|file:|-)|ssh-keygen .* -P( |$)' -- . ':!**/.git/**' 2>/dev/null || true)
          if [ -n "$bad" ]; then
            echo "::error::interactive signing patterns found"
            echo "$bad"
            exit 1
          fi

  # ---------------- Audit streaming guard (S3) ----------------
  audit_streaming_guard:
    if: ${{ vars.AUDIT_BUCKET != '' }}
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
          audience: sts.amazonaws.com
          role-session-name: gha-${{ github.run_id }}-${{ github.run_attempt }}
      - name: Check bucket exists
        env:
          B: ${{ vars.AUDIT_BUCKET }}
        run: |
          set -euo pipefail
          aws s3api head-bucket --bucket "$B" || { echo "::error::Bucket $B not found"; exit 1; }
          aws s3api get-bucket-location --bucket "$B" --output json || true
      - name: Saw audit objects in last 7d
        env:
          B: ${{ vars.AUDIT_BUCKET }}
          P: ${{ vars.AUDIT_PREFIX }}
        run: |
          set -euo pipefail
          since=$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ)
          aws s3api list-objects-v2 --bucket "$B" --prefix "${P:-}" --query \
            "Contents[?LastModified>=\`$since\`][].{Key:Key,LastModified:LastModified}" \
            --output json | jq -e 'length>0' >/dev/null || {
              echo "::warning::no audit objects in last 7d"; true; }
      - name: Summarize recent audit objects (CI/CD categories)
        env:
          B: ${{ vars.AUDIT_BUCKET }}
          P: ${{ vars.AUDIT_PREFIX }}
        shell: bash
        run: |
          set -euo pipefail
          KEYS_JSON=$(aws s3api list-objects-v2 --bucket "$B" --prefix "${P:-}" \
            --query 'reverse(sort_by(Contents,&LastModified))[:100].Key' --output json)
          mapfile -t KEYS < <(jq -r '.[]?' <<<"$KEYS_JSON")
          if [ ${#KEYS[@]} -eq 0 ]; then
            echo "::notice::bucket empty"; exit 0; fi
          tmp_all="$(mktemp)"; fetched=0
          for k in "${KEYS[@]}"; do
            if ! aws s3api head-object --bucket "$B" --key "$k" >/dev/null 2>&1; then
              echo "::notice::skip missing/deleted object: $k"; continue; fi
            if aws s3 cp "s3://$B/$k" - 2>/dev/null | gzip -dc 2>/dev/null >>"$tmp_all"; then
              echo "::notice::parsed $k"; fetched=1; fi
          done
          if [ $fetched -eq 0 ]; then
            echo "::notice::could not read any of the recent objects"; exit 0; fi
          total=$(wc -l < "$tmp_all" || echo 0)
          echo "Total events parsed: $total"
          acts="$(mktemp)"
          jq -r '.action // empty' "$tmp_all" > "$acts" || true
          echo "Top action categories (prefix):"
          awk -F'[._]' 'NF{print $1}' "$acts" | sort | uniq -c | sort -nr | head -n 20 | sed 's/^/  /'
          ci=$(grep -Ec '^(workflows\.|artifact\.|repo\.|repository_|checks\.|environment\.)' "$acts" || true)
          if [ "$ci" -gt 0 ]; then
            echo "✓ Found ${ci} CI/CD audit events (workflows/artifact/repo/checks/environment)."
          else
            echo "::notice::no CI/CD audit events among the last ${#KEYS[@]} objects."
          fi
      - name: Lifecycle retention ≥30d
        env:
          B: ${{ vars.AUDIT_BUCKET }}
        run: |
          set -euo pipefail
          lc=$(aws s3api get-bucket-lifecycle-configuration --bucket "$B" 2>/dev/null || echo "")
          days=$(jq -r '[.Rules[]?.Expiration?.Days // empty] | max // 0' <<<"$lc")
          if [ "${days:-0}" -lt 30 ]; then
            echo "::warning::No lifecycle expiration ≥30d on $B"; true
          else
            echo "Retention OK (${days}d)"
          fi

  # ---------------- Rerun guard ----------------
  rerun_guard:
    runs-on: ubuntu-latest
    steps:
      - name: Block rerun without explicit approval (PR only)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          ATTEMPT: ${{ github.run_attempt }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if [ "${ATTEMPT:-1}" -gt 1 ]; then
            pr=$(jq -r .number "$GITHUB_EVENT_PATH")
            labels=$(gh pr view "$pr" --json labels -q '.labels[].name' | tr '\n' ' ')
            echo "$labels" | grep -q 'Re-Run-Approved' || {
              echo "::warning::Rerun needs label Re-Run-Approved"; true; }
          else
            echo "first attempt -> OK"
          fi

  # ---------------- Release-only gate + trust-store verify for deploy ----------------
  prod_release_gate:
    needs: [access_recert_gate, build_and_attest, trust_store_guard, kms_sign_and_verify, sbom_enforce, verify_action_publishers]
    if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Load org trust-store (required in this job)
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          SRC=""
          if [ -n "${ORG_TRUST_REPO:-}" ]; then
            echo "Cloning trust-store from ${ORG_TRUST_REPO}…"
            if gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
              if [ -d _orgtrust/.github/trust ]; then
                cp -a _orgtrust/.github/trust/. .github/trust/
                SRC="org:${ORG_TRUST_REPO}"
              fi
            else
              echo "::notice::gh clone failed (private repo or ORG_READ_TOKEN missing?)"
            fi
          fi
          # If org sync didn't work but repo already has trust-store — use it
          if [ -z "$SRC" ] && [ -f ".github/trust/publishers.jwks.json" ]; then
            SRC="local:.github/trust"
          fi
          echo "Using trust-store source: ${SRC:-<none>}"
          ls -la .github/trust || true
          # Hard fail with actionable message if still missing
          if [ ! -f ".github/trust/publishers.jwks.json" ]; then
            echo "::error::missing .github/trust/publishers.jwks.json. Set repo var ORG_TRUST_REPO (owner/repo) and secret ORG_READ_TOKEN with read access to it, or commit .github/trust/* to this repo."
            exit 1
          fi
          test -f .github/trust/allowed_signers.json || { echo "::error::missing .github/trust/allowed_signers.json"; exit 1; }

      - name: Enforce release-only refs
        shell: bash
        run: |
          set -euo pipefail
          case "${GITHUB_REF}" in refs/heads/main|refs/heads/release/*|refs/tags/v*) ;; *)
            echo "::error::Deploy allowed only from main/release/*/v*"; exit 1;; esac

      - name: Check key revocations
        run: |
          set -euo pipefail
          KID="AWS:${{ vars.AWS_KMS_KEY_ID }}"
          test -f .github/trust/revocations.json || { echo "no revocations.json -> OK"; exit 0; }
          jq -r '.kids[]?' .github/trust/revocations.json | grep -Fx "$KID" && {
            echo "::error::Key revoked ($KID)"; exit 1; } || echo "KID not revoked"

      - name: Enforce signer present in JWKS (unknown ⇒ block)
        shell: bash
        env:
          KID: AWS:${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          test -f .github/trust/publishers.jwks.json || { echo "::error::missing .github/trust/publishers.jwks.json"; exit 1; }
          jq -e --arg k "$KID" '.keys[]?|.kid==$k' .github/trust/publishers.jwks.json >/dev/null || { echo "::error::unknown signer $KID (not in .github/trust/publishers.jwks.json)"; exit 1; }

      - name: Verify OIDC claims + allowed_signers
        shell: bash
        run: |
          set -euo pipefail
          test -f .github/trust/allowed_signers.json || { echo "::error::missing .github/trust/allowed_signers.json"; exit 1; }

          echo "has URL: ${ACTIONS_ID_TOKEN_REQUEST_URL:+yes}  has TOKEN: ${ACTIONS_ID_TOKEN_REQUEST_TOKEN:+yes}"

          tok=$(curl -fsSL \
                 -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
                 "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=sts.amazonaws.com" \
                 | jq -r .value)

          if ! echo "$tok" | grep -q '\.'; then
            echo "::error::failed to obtain OIDC token (check permissions: id-token: write)"; exit 1
          fi

          body=$(cut -d. -f2 <<<"$tok" | base64 -d 2>/dev/null || true)
          repo=$(jq -er '.repository' <<<"$body") || { echo "::error::bad OIDC body"; exit 1; }
          ref=$(jq -r '.ref // empty' <<<"$body")
          wf=$(jq -r '.job_workflow_ref // empty' <<<"$body")

          echo "repo=$repo"
          echo "ref=$ref"
          echo "wf=$wf"

          [ "$repo" = "${GITHUB_REPOSITORY}" ] || { echo "::error::OIDC repo mismatch"; exit 1; }
          echo "$ref" | grep -Eq '^refs/(heads/(main|release/.*)|tags/v.*)$' || { echo "::error::OIDC ref not allowed ($ref)"; exit 1; }

          wfbase="${wf%@*}"
          if jq -e --arg wf "$wf" --arg wb "$wfbase" \
               'type=="array" and (map(select(.==$wf or .==$wb)) | length > 0)' \
               .github/trust/allowed_signers.json >/dev/null; then
            echo "workflow allowed"
          else
            echo "::error::workflow not in allowed_signers (wf=$wf; wfbase=$wfbase)"
            cat .github/trust/allowed_signers.json
            exit 1
          fi

  # ---------------- Promote to Production ----------------
  promote_to_prod:
    needs: [prod_release_gate]
    runs-on: ubuntu-latest
    environment:
      name: production
    concurrency:
      group: deploy-${{ github.ref_name }}
    steps:
      - run: echo "All upstream gates passed. Waiting for env approval…"

  # ---------------- Rollback to Production ----------------
  rollback_to_prod:
    
    if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    needs: [prod_release_gate, access_recert_gate]
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - run: echo "Manual rollback to production requested. Waiting for environment approval..."

  # ---------------- Admin operations ----------------
  secrets_kms_admin:
    needs: [access_recert_gate]
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: admin-ops
    steps:
      - run: echo "Admin operation on secrets/KMS. Waiting for environment approval..."

  rbac_admin:
    needs: [access_recert_gate]
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: admin-ops
    steps:
      - run: echo "Admin operation on RBAC/permissions. Waiting for environment approval..."

  trust_runners_admin:
    needs: [access_recert_gate]
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: admin-ops
    steps:
      - run: echo "Admin operation on trusted/registration runners. Waiting for environment approval..."

  # ---------------- Trust-store auto-rotation ----------------
  trust_store_rotate:
    if: ${{ github.event_name == 'schedule' && vars.ORG_TRUST_REPO != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Pull org trust-store
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        run: |
          set -euo pipefail
          rm -hf _orgtrust || true
          rm -rf _orgtrust
          gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q
          test -d _orgtrust/.github/trust || { echo "no .github/trust in $ORG_TRUST_REPO"; exit 0; }
          mkdir -p .github/trust
          cp -a _orgtrust/.github/trust/. .github/trust/
      - name: Detect changes
        id: diff
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          BR="chore/rotate-trust-store-$(date -u +%Y%m%d%H%M%S)"
          git checkout -b "$BR"
          git add .github/trust
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            git commit -m "chore(trust-store): sync from ${{ vars.ORG_TRUST_REPO }}"
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "branch=$BR" >> "$GITHUB_OUTPUT"
          fi
      - name: Open PR
        if: steps.diff.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh pr create \
            --title "chore(trust-store): sync org trust-store" \
            --body "Automated sync of .github/trust from \`${{ vars.ORG_TRUST_REPO }}\`" \
            --base "main" || true

  # ---------------- Presence-gate + baseline governance ----------------
  presence_gate:
    needs: [codeql, dependency_review, secrets_presence_gate]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    permissions:
      contents: read
      pull-requests: read
      security-events: read
    steps:
      - name: Require SAST/SCA/Secrets to have RUN (skip ⇒ WARN)
        shell: bash
        run: |
          set -euo pipefail
          SAST="${{ needs.codeql.result }}"
          SCA="${{ needs.dependency_review.result }}"
          SECR="${{ needs.secrets_presence_gate.result }}"
          echo "SAST=$SAST  SCA=$SCA  SECRETS=$SECR"
          warn=0
          for n in "SAST:$SAST" "SCA:$SCA" "SECRETS:$SECR"; do
            k="${n%%:*}"; v="${n##*:}"
            if [ "$v" = "skipped" ] || [ "$v" = "cancelled" ]; then
              echo "::warning::$k scan was $v (required to run)"
              warn=1
            fi
          done
          [ $warn -eq 0 ] && echo "All presence checks ran ✅" || echo "Presence WARNs emitted"

      - name: Baseline governance (changes require review)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          pr=$(jq -r .number "$GITHUB_EVENT_PATH")
          repo="${GITHUB_REPOSITORY}"
          PATTERN='^(\.github/security-baselines/|\.codeql/|baseline/|secrets\.allowlist|trivy\.ignore|codeql\.sarif)$'
          changed=$(gh api repos/$repo/pulls/$pr/files --paginate -q '.[].filename' | tr -d '\r' || true)
          echo "$changed" | grep -E "$PATTERN" >/dev/null 2>&1 || exit 0
          has_label=$(gh pr view "$pr" --repo "$repo" --json labels -q '[.labels[]?.name] | index("Baseline-Reviewed") != null')
          has_reason=$(gh pr view "$pr" --repo "$repo" --json body   -q '(.body // "") | test("(?i)(baseline|suppression|обосн|подавлен|reason)")')
          if [ "$has_label" != "true" ] && [ "$has_reason" != "true" ]; then
            echo "::error::Baseline changes detected; add label 'Baseline-Reviewed' or put rationale in PR description"
            exit 1
          fi
          echo "Baseline changes are reviewed ✅"

  # ---------------- Collect reports (JSON/TXT) ----------------
  collect_security_reports:
    needs: [presence_gate]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    permissions:
      contents: read
      security-events: read
      pull-requests: read
    steps:
      - name: Gather reports
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p _reports
          repo="${GITHUB_REPOSITORY}"
          gh api repos/$repo/code-scanning/alerts --paginate > _reports/codeql_alerts.json || echo '[]' > _reports/codeql_alerts.json
          gh api repos/$repo/dependabot/alerts --paginate > _reports/dependabot_alerts.json || echo '[]' > _reports/dependabot_alerts.json
          jq -n --arg SAST "${{ needs.codeql.result }}" \
                --arg SCA  "${{ needs.dependency_review.result }}" \
                --arg SECR "${{ needs.secrets_presence_gate.result }}" \
                '{sast:$SAST, sca:$SCA, secrets:$SECR}' > _reports/presence.json
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: security-reports
          path: _reports
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: security-reports
          path: _reports/*
          overwrite: true

  # ---------------- Release protection (no over-publish) ----------------
  release_protection:
    if: ${{ startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Block if release already exists for this tag
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag="${GITHUB_REF#refs/tags/}"
          if gh release view "$tag" >/dev/null 2>&1; then
            echo "::error::Release ${tag} already exists — publishing over release is forbidden"
            exit 1
          fi
          echo "No existing release for ${tag} -> OK"

  # ---------------- Attach reports to Release on tag ----------------
  attach_security_reports:
    needs: [collect_security_reports, release_protection]
    if: ${{ startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      security-events: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: security-reports
          path: reports
          overwrite: true
      - name: Upload reports to Release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${GITHUB_REF#refs/tags/}"
          gh release view "$tag" >/dev/null 2>&1 || gh release create "$tag" -t "$tag" -n "Automated release"
          ls -l reports || true
          gh release upload "$tag" reports/* --clobber || true

  # ---------------- M2: Audit workflow/plugins & block exfil in changed workflows ----------------
  audit_ci_changes:
    name: M2 — Audit workflow/plugins & exfil (enterprise-safe)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Compute changed files (no external actions)
        id: cf
        shell: bash
        run: |
          set -euo pipefail
          get_changed() {
            if [ "${GITHUB_EVENT_NAME}" = "pull_request" ]; then
              base=$(jq -r .pull_request.base.sha "$GITHUB_EVENT_PATH")
              head="${GITHUB_SHA}"
              git fetch --no-tags --prune --depth=1 origin "$base" >/dev/null 2>&1 || true
              git diff --name-only "$base" "$head"
            else
              before=$(jq -r '.before // empty' "$GITHUB_EVENT_PATH")
              if [ -n "$before" ] && [ "$before" != "0000000000000000000000000000000000000000" ]; then
                git diff --name-only "$before" "$GITHUB_SHA"
              else
                git fetch --no-tags --prune --depth=2 origin "${GITHUB_REF}" >/dev/null 2>&1 || true
                git diff --name-only "${GITHUB_SHA}^" "$GITHUB_SHA" 2>/dev/null || true
              fi
            fi
          }
          CHANGED="$(get_changed | tr -d '\r' | sed 's|^\./||')"
          echo "all_changed_files<<__EOF__" >> "$GITHUB_OUTPUT"
          echo "$CHANGED" >> "$GITHUB_OUTPUT"
          echo "__EOF__" >> "$GITHUB_OUTPUT"
          if printf '%s\n' "$CHANGED" | grep -E '^\.?github/workflows/.*\.ya?ml$' >/dev/null; then
            echo "any_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "any_changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Validate action owners + pin to full SHA (WARN only)
        if: steps.cf.outputs.any_changed == 'true'
        shell: bash
        env:
          ALLOW_OWNERS: actions|github|aws-actions|google-github-actions|dependabot|azure
        run: |
          set -euo pipefail
          status=0
          while IFS= read -r f; do
            [ -n "$f" ] || continue
            echo "::group::Check $f"
            mapfile -t USES < <(awk '/uses:/{print $0}' "$f" | sed -E 's/^[[:space:]-]*uses:[[:space:]]*//')
            for u in "${USES[@]}"; do
              owner=$(echo "$u" | awk -F'[/:@]' '{print $1}')
              ref=$(echo "$u"   | awk -F'@' '{print $2}')
              if ! [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
                echo "::error file=$f::'$u' is NOT pinned to full 40-char commit SHA"; status=1
              fi
              if ! [[ "$owner" =~ ^(${ALLOW_OWNERS})$ ]]; then
                echo "::error file=$f::owner '$owner' is not allowed by enterprise policy"; status=1
              fi
            done
            echo "::endgroup::"
          done < <(printf '%s\n' "${{ steps.cf.outputs.all_changed_files }}" | grep -E '^\.?github/workflows/.*\.ya?ml$' || true)
          if [ $status -ne 0 ]; then
            echo "::warning::violations found, but WARN mode → not failing"
            exit 0
          fi

      - name: actionlint (download binary, WARN only)
        if: steps.cf.outputs.any_changed == 'true'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          ver="1.7.1"
          url="https://github.com/rhysd/actionlint/releases/download/v${ver}/actionlint_${ver}_linux_amd64.tar.gz"
          curl -fsSL "$url" -o /tmp/actionlint.tgz
          tar -xzf /tmp/actionlint.tgz -C /tmp actionlint
          /tmp/actionlint -color -format '{{.File}}:{{.Line}}:{{.Col}}: {{.Kind}}: {{.Message}}'

      - name: Block artifact exfil when added
        if: steps.cf.outputs.any_changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          bad=0
          while IFS= read -r f; do
            [ -n "$f" ] || continue
            if grep -nE "upload-artifact|download-artifact" "$f"; then
              echo "::error file=$f::Found upload/download-artifact in changed workflow. Remove or justify."
              bad=1
            fi
          done < <(printf '%s\n' "${{ steps.cf.outputs.all_changed_files }}" | grep -E '^\.?github/workflows/.*\.ya?ml$' || true)
          if [ $bad -ne 0 ]; then
            echo "::warning::artifact exfil pattern found (WARN mode)"; exit 0
          fi