name: Security Framework Gates

on:
  push:
    branches: ["main", "release/*"]
    tags: ["v*"]
  pull_request:
    branches: ["main", "release/*"]
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      tamper_sbom:
        description: "Tamper artifact AFTER SBOM?"
        required: false
        type: boolean
        default: false
  schedule:
    - cron: "0 0 * * 1"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write
  packages: read
  id-token: write
  attestations: write

env:
  ENFORCEMENT: warn
  CAN_ATTEST: ${{ (github.event_name == 'push') || (github.event_name == 'workflow_dispatch') || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) }}

jobs:
  security_settings_guard:
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS for GH App secret (OIDC)
        uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Fetch GH App key from AWS Secrets Manager (robust)
        id: fetch_appkey
        shell: bash
        env:
          GHAPP_PRIVATE_KEY_SECRET_ID: ${{ vars.GHAPP_PRIVATE_KEY_SECRET_ID }}
        run: |
          set -euo pipefail
          umask 077
          [ -n "${GHAPP_PRIVATE_KEY_SECRET_ID:-}" ] || { echo "::error::vars.GHAPP_PRIVATE_KEY_SECRET_ID is empty"; exit 1; }
          RAW="$(aws secretsmanager get-secret-value \
            --secret-id "$GHAPP_PRIVATE_KEY_SECRET_ID" \
            --query SecretString --output text)"
          if printf '%s' "$RAW" | head -n1 | grep -q -- '-----BEGIN '; then
            printf '%s' "$RAW" > app.pem
          else
            VAL="$(printf '%s' "$RAW" | jq -r '.value // empty' || true)"
            if [ -n "${VAL:-}" ] && printf '%s' "$VAL" | head -n1 | grep -q -- '-----BEGIN '; then
              printf '%s' "$VAL" > app.pem
            else
              echo "::error::Secret is not a PEM. Store raw PEM or JSON {\"value\":\"PEM\"}."
              exit 1
            fi
          fi
          openssl pkey -in app.pem -noout >/dev/null 2>&1 || { echo "::error::Invalid PEM in app.pem"; exit 1; }
          echo "app.pem ready"

      - name: Get GitHub App installation token (no external action)
        id: app_token
        env:
          APP_ID: ${{ secrets.GHAPP_ID }}
          API_URL: ${{ github.api_url }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${APP_ID:-}" ] || { echo "::error::secrets.GHAPP_ID is empty"; exit 1; }
          b64url() { openssl base64 -A | tr '+/' '-_' | tr -d '='; }
          NOW=$(date +%s); EXP=$((NOW+540))
          HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | b64url)
          PAY=$(printf '{"iat":%s,"exp":%s,"iss":"%s"}' "$NOW" "$EXP" "$APP_ID" | b64url)
          SIGN_INPUT="${HDR}.${PAY}"
          SIG=$(printf %s "$SIGN_INPUT" | openssl dgst -sha256 -sign app.pem -binary | b64url)
          JWT="${SIGN_INPUT}.${SIG}"
          API="${API_URL:-https://api.github.com}"
          INST_JSON=$(curl -fsSL \
            -H "Authorization: Bearer ${JWT}" \
            -H "Accept: application/vnd.github+json" \
            "${API}/repos/${REPO}/installation")
          INST_ID=$(jq -er '.id' <<<"$INST_JSON") || { echo "::error::Cannot read installation id. Is the App installed on this repo?"; exit 1; }
          TOKEN_JSON=$(curl -fsSL -X POST \
            -H "Authorization: Bearer ${JWT}" \
            -H "Accept: application/vnd.github+json" \
            "${API}/app/installations/${INST_ID}/access_tokens")
          TOKEN=$(jq -er '.token' <<<"$TOKEN_JSON") || { echo "::error::Cannot mint installation token"; exit 1; }
          echo "::add-mask::${TOKEN}"
          echo "GH_TOKEN=${TOKEN}" >> "$GITHUB_ENV"
          shred -u app.pem || rm -f app.pem

      - name: Check repo security flags
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          DATA=$(gh api -H "Accept: application/vnd.github+json" "repos/${REPO}" || true)
          SEC=$(echo "$DATA" | jq -r '.security_and_analysis // empty' 2>/dev/null || true)
          SS=$(echo "$SEC" | jq -r 'try .secret_scanning.status // empty' 2>/dev/null || true)
          PP=$(echo "$SEC" | jq -r 'try .secret_scanning_push_protection.status // empty' 2>/dev/null || true)

          echo "Secret scanning: ${SS:-unknown}, Push protection: ${PP:-unknown}"

          if [ -z "${SS:-}" ] || [ -z "${PP:-}" ]; then
            echo "::warning::security_and_analysis is unavailable in this GitHub Enterprise for ${REPO}. Skipping."
            exit 0
          fi

          if [ "$SS" != "enabled" ] || [ "$PP" != "enabled" ]; then
            echo "::error::Enable Secret scanning + Push Protection."
            exit 1
          fi

  change_reason_gate:
    name: Change-Reason Gate
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    env:
      CHANGE_REASON_REGEX: ${{ vars.CHANGE_REASON_REGEX }}
      CHANGE_REASON_LABEL_REGEX: ${{ vars.CHANGE_REASON_LABEL_REGEX }}
    steps:
      - name: Require Change-ID/Ticket in PR (title/body/labels)
        shell: bash
        run: |
          set -euo pipefail
          RE="${CHANGE_REASON_REGEX:-'(Change-ID:[[:space:]]*[A-Za-z0-9._/-]+|Ticket:[[:space:]]*[A-Za-z0-9._/-]+|[A-Z][A-Z0-9]+-[0-9]+)'}"
          LRE="${CHANGE_REASON_LABEL_REGEX:-''}"
          title="$(jq -r '.pull_request.title // ""' "$GITHUB_EVENT_PATH")"
          body="$(jq -r '.pull_request.body // ""' "$GITHUB_EVENT_PATH")"
          labels="$(jq -r '.pull_request.labels[]?.name // empty' "$GITHUB_EVENT_PATH" | tr '\n' ' ')"
          text="$title"$'\n'"$body"$'\n'"$labels"
          if echo "$text" | grep -Eiq "$RE"; then
            exit 0
          fi
          if [ -n "$LRE" ] && echo "$labels" | grep -Eiq "$LRE"; then
            exit 0
          fi
          msg="No Change-ID/Ticket reference found in PR title/body/labels (expected: $RE)"
          if [ "${ENFORCEMENT:-warn}" = "block" ]; then
            echo "::error::$msg"
            exit 1
          else
            echo "::warning::$msg"
          fi

  pr_policy_gate:
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    steps:
      - name: Require >=1 APPROVED review and change reason
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          pr=$(jq -r .number "$GITHUB_EVENT_PATH")
          repo="${GITHUB_REPOSITORY}"
          approved=$(gh pr view "$pr" --repo "$repo" --json reviews -q \
            '[.reviews[]?|select(.state=="APPROVED")] | length')
          if [ "${approved:-0}" -lt 1 ]; then
            echo "::error::Need at least 1 APPROVED review"
            exit 1
          fi
          has_label=$(gh pr view "$pr" --repo "$repo" --json labels -q \
            '[.labels[]?.name] | index("Change-Reason") != null')
          has_reason=$(gh pr view "$pr" --repo "$repo" --json body -q \
            '(.body // "") | test("(?i)(reason|why|motivation|обосн|причин)")')
          if [ "$has_label" != "true" ] && [ "$has_reason" != "true" ]; then
            echo "::error::Provide change reason (label Change-Reason or reason in PR body)"
            exit 1
          fi

  push_pr_only_gate:
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    steps:
      - name: Enforce PR-only for protected branches
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          case "${GITHUB_REF}" in
            refs/heads/main|refs/heads/release/*) ;;
            *) exit 0 ;;
          esac
          repo="${GITHUB_REPOSITORY}"
          prs=$(gh api -H "Accept: application/vnd.github+json" \
            "repos/${repo}/commits/${GITHUB_SHA}/pulls" -q 'length' || echo 0)
          if [ "${prs:-0}" -lt 1 ]; then
            echo "::error::Commit not associated with a PR"
            exit 1
          fi
          pr=$(gh api -H "Accept: application/vnd.github+json" \
            "repos/${repo}/commits/${GITHUB_SHA}/pulls" -q '.[0].number')
          approved=$(gh pr view "$pr" --repo "$repo" --json reviews -q \
            '[.reviews[]?|select(.state=="APPROVED")] | length')
          if [ "${approved:-0}" -lt 1 ]; then
            echo "::error::No APPROVED reviews on PR #$pr"
            exit 1
          fi
          has_label=$(gh pr view "$pr" --repo "$repo" --json labels -q \
            '[.labels[]?.name] | index("Change-Reason") != null')
          has_reason=$(gh pr view "$pr" --repo "$repo" --json body -q \
            '(.body // "") | test("(?i)(reason|why|motivation|обосн|причин)")')
          if [ "$has_label" != "true" ] && [ "$has_reason" != "true" ]; then
            echo "::error::PR #$pr has no change reason"
            exit 1
          fi

  encrypted_at_rest_policy:
    if: ${{ vars.BACKUP_BUCKET != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      BACKUP_BUCKET: ${{ vars.BACKUP_BUCKET }}
    steps:
      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
          audience: sts.amazonaws.com

      - name: Enforce SSE-KMS on backup bucket
        shell: bash
        run: |
          set -euo pipefail
          enc=$(aws s3api get-bucket-encryption --bucket "$BACKUP_BUCKET" \
            --query 'ServerSideEncryptionConfiguration.Rules[0].ApplyServerSideEncryptionByDefault.SSEAlgorithm' \
            --output text 2>/dev/null || echo "NONE")
          if [ "$enc" != "aws:kms" ]; then
            msg="Bucket $BACKUP_BUCKET not SSE-KMS (enc=$enc)"
            if [ "${ENFORCEMENT:-warn}" = "block" ]; then
              echo "::error::$msg"; exit 1
            else
              echo "::warning::$msg"
            fi
          fi

      - name: Enforce lifecycle >=30 days
        shell: bash
        run: |
          set -euo pipefail
          lc=$(aws s3api get-bucket-lifecycle-configuration --bucket "$BACKUP_BUCKET" 2>/dev/null || echo "")
          days=$(jq -r '[.Rules[]?.Expiration?.Days // empty] | max // 0' <<<"$lc")
          if [ "${days:-0}" -lt 30 ]; then
            msg="No Expiration >=30d on $BACKUP_BUCKET (days=${days:-0})"
            if [ "${ENFORCEMENT:-warn}" = "block" ]; then
              echo "::error::$msg"; exit 1
            else
              echo "::warning::$msg"
            fi
          fi

  no_floating_images:
    name: M2 — forbid ':latest' and unpinned base images
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Fail on floating Docker base images
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t DF < <(git ls-files | grep -Ei '(^|/)(Dockerfile|.*\.Dockerfile)$' || true)
          [ ${#DF[@]} -gt 0 ] || { echo "No Dockerfiles found"; exit 0; }
          bad=0
          for f in "${DF[@]}"; do
            while IFS= read -r line; do
              img=$(sed -E 's/^[[:space:]]*FROM[[:space:]]+//I; s/[[:space:]]+AS.*$//I' <<<"$line")
              if grep -Eq ':[[:alnum:]_.-]+(@sha256:[0-9a-f]{64})?$' <<<"$img"; then
                tag="${img##*:}"
                if [[ "$tag" == "latest" ]]; then
                  echo "::error file=$f::FROM uses ':latest' → $line"
                  bad=1
                fi
              elif grep -Eq '@sha256:[0-9a-f]{64}$' <<<"$img"; then
                :
              else
                echo "::error file=$f::FROM without explicit tag or digest → $line"
                bad=1
              fi
            done < <(grep -Ei '^[[:space:]]*FROM[[:space:]]+' "$f" | grep -Ev '^[[:space:]]*#')
          done
          if [ $bad -ne 0 ]; then
            exit 1
          fi

  codeql:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Detect CodeQL languages (avoid JS/TS error if none)
        shell: bash
        run: |
          set -euo pipefail
          langs="actions,python"
          if git ls-files '*.js' '*.jsx' '*.ts' '*.tsx' 'package.json' 'tsconfig.json' | head -n1 | grep -q .; then
            langs="${langs},javascript"
          fi
          echo "CODEQL_LANGUAGES=${langs}" >> "$GITHUB_ENV"
          echo "Using CodeQL languages: ${langs}"

      - uses: github/codeql-action/init@192325c86100d080feab897ff886c34abd4c83a3
        with:
          languages: ${{ env.CODEQL_LANGUAGES }}
      - uses: github/codeql-action/analyze@192325c86100d080feab897ff886c34abd4c83a3

  dependency_review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Compute base/head refs
        id: deprefs
        shell: bash
        run: |
          set -euo pipefail
          HEAD_SHA="${GITHUB_SHA}"
          if [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            BEFORE="$(jq -r .before "$GITHUB_EVENT_PATH")"
            if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
              echo "base=$BEFORE" >> "$GITHUB_OUTPUT"
            else
              git fetch --no-tags --prune --depth=2 origin "${GITHUB_REF}"
              echo "base=$(git rev-parse "${HEAD_SHA}^" 2>/dev/null || echo '')" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "base=$(jq -r .pull_request.base.sha "$GITHUB_EVENT_PATH")" >> "$GITHUB_OUTPUT"
          fi
      - uses: actions/dependency-review-action@595b5aeba73380359d98a5e087f648dbb0edce1b
        if: steps.deprefs.outputs.base != ''
        with:
          base-ref: ${{ steps.deprefs.outputs.base }}
          head-ref: ${{ github.sha }}
          fail-on-severity: critical
        continue-on-error: true

  verify_action_publishers:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Verify publishers + pin to commit (WARN only)
        env:
          GH_TOKEN: ${{ github.token }}
          ALLOW_OWNERS: actions|github|aws-actions|google-github-actions|dependabot|azure
          YQ_VER: ${{ vars.YQ_VERSION }}
          YQ_SHA512: ${{ vars.YQ_SHA512 }}
        shell: bash
        run: |
          set -euo pipefail
          YQ_VERSION="${YQ_VER:-v4.44.3}"
          if [ -n "${YQ_SHA512:-}" ]; then
            sudo curl -fsSL -L -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
            echo "${YQ_SHA512}  /usr/local/bin/yq" | sha512sum -c -
            sudo chmod +x /usr/local/bin/yq
          else
            sudo curl -fsSL -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
            sudo chmod +x /usr/local/bin/yq
            echo "::warning::YQ_SHA512 repo variable not set — checksum for yq not verified"
          fi
          status=0
          mapfile -t WF < <(git ls-files '.github/workflows/*.y*ml' 2>/dev/null || true)
          for f in "${WF[@]}"; do
            while read -r line; do
              u="${line#uses: }"
              owner=$(echo "$u" | awk -F'[/:@]' '{print $1}')
              sha=$(echo "$u" | awk -F'@' '{print $2}')
              if ! [[ "$owner" =~ ^(${ALLOW_OWNERS})$ ]]; then
                echo "::error file=$f::owner '$owner' is not allowed by enterprise policy"
                status=1
              fi
              if ! [[ "$sha" =~ ^[0-9a-f]{40}$ ]]; then
                echo "::error file=$f::'$u' is NOT pinned to full 40-char commit SHA"
                status=1
              fi
            done < <(yq -r '.. | .uses? | select(type=="string") | "uses: "+.' "$f")
          done
          if [ $status -ne 0 ]; then
            exit 0
          fi

  build_and_attest:
    needs: [codeql, dependency_review, verify_action_publishers]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      attestations: write
      id-token: write
    env:
      GH_TOKEN: ${{ github.token }}
      SYFT_VER: ${{ vars.SYFT_VERSION }}
      SYFT_TGZ_SHA256: ${{ vars.SYFT_TGZ_SHA256 }}
    steps:
      - name: (light) egress log
        shell: bash
        run: |
          echo "Open connections BEFORE:"; ss -tpn || true
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Build artifact
        run: |
          echo "hello $(date -u +%FT%TZ)" > artifact.txt
          sha256sum artifact.txt | tee checksums.txt
      - name: Export SBOM (Syft)
        shell: bash
        run: |
          set -euo pipefail
          VER="${SYFT_VER:-v1.33.0}"
          curl -fsSL -o syft.tgz "https://github.com/anchore/syft/releases/download/${VER}/syft_${VER#v}_linux_amd64.tar.gz" || \
          curl -fsSL -o syft.tgz "https://github.com/anchore/syft/releases/download/${VER}/syft_Linux_x86_64.tar.gz"
          if [ -n "${SYFT_TGZ_SHA256:-}" ]; then
            echo "${SYFT_TGZ_SHA256}  syft.tgz" | sha256sum -c -
          else
            echo "::warning::SYFT_TGZ_SHA256 repo variable not set — checksum for syft.tgz not verified"
          fi
          tar -xzf syft.tgz syft && sudo install -m0755 syft /usr/local/bin/syft
          syft "file:artifact.txt" -o spdx-json=sbom.spdx.json
          D=$(sha256sum artifact.txt | awk '{print $1}')
          jq --arg d "$D" '.files=((.files // [])|map(select(.fileName!="artifact.txt")))+
             [{"fileName":"artifact.txt","SPDXID":"SPDXRef-File-artifact.txt","checksums":[{"algorithm":"SHA256","checksumValue":$d}]}]' \
             sbom.spdx.json > t && mv t sbom.spdx.json
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: build
          path: |
            artifact.txt
            checksums.txt
            sbom.spdx.json
      - name: Attest provenance
        if: env.CAN_ATTEST == 'true'
        uses: actions/attest-build-provenance@ef244123eb79f2f7a7e75d99086184180e6d0018
        with:
          subject-path: artifact.txt
      - name: Attest SBOM
        if: env.CAN_ATTEST == 'true'
        uses: actions/attest-sbom@5026d3663739160db546203eeaffa6aa1c51a4d6
        with:
          subject-path: artifact.txt
          sbom-path: sbom.spdx.json
      - name: Verify attestations
        if: env.CAN_ATTEST == 'true'
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          set -euo pipefail
          if ! gh attestation --help >/dev/null 2>&1; then
            gh extension install github/gh-attestation
          fi
          WF="${GITHUB_WORKFLOW_REF}"
          REPO="${GITHUB_REPOSITORY}"
          successes=0; failures=0
          for PT in "https://slsa.dev/provenance/v1" "https://spdx.dev/Document"; do
            verified=0
            for i in $(seq 1 8); do
              if gh attestation verify artifact.txt \
                    --repo "${REPO}" \
                    --predicate-type "${PT}" \
                    --cert-oidc-issuer "https://token.actions.githubusercontent.com" \
                    --signer-workflow "${WF}" \
                    --deny-self-hosted-runners --limit 50; then
                verified=1; break; fi
              sleep 10
            done
            if [ $verified -eq 1 ]; then successes=$((successes+1)); else failures=$((failures+1)); fi
          done
          [ $failures -eq 0 ] || true

  tamper_after_sbom:
    name: "⚠️ tamper_after_sbom"
    needs: [build_and_attest]
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.tamper_sbom == 'true' }}
    steps:
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build
      - name: Tamper artifact AFTER SBOM
        shell: bash
        run: |
          set -euo pipefail
          printf '\nTAMPERED %s\n' "$(date -u +%FT%TZ)" >> artifact.txt
          sha256sum artifact.txt | tee checksums.txt
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: build
          path: |
            artifact.txt
            checksums.txt
            sbom.spdx.json
          overwrite: true

  trust_store_guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Load org trust-store (if set)
        id: t
        shell: bash
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          SRC=""
          if [ -n "${ORG_TRUST_REPO:-}" ]; then
            if gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
              if [ -d _orgtrust/.github/trust ]; then
                cp -a _orgtrust/.github/trust/. .github/trust/
                SRC="org:${ORG_TRUST_REPO}"
              fi
            else
              echo "::notice::gh clone failed (private repo or GH_TOKEN missing?)"
            fi
          fi
          if [ -z "$SRC" ] && [ -d ".github/trust" ] && [ -f ".github/trust/publishers.jwks.json" ]; then
            SRC="local:.github/trust (already present)"
          fi
          echo "source=${SRC:-none}" >> "$GITHUB_OUTPUT"
          ls -la .github/trust || true
      - name: Validate trust-store files
        env:
          AWS_KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          test -f .github/trust/publishers.jwks.json || { echo "::error::JWKS missing (.github/trust/publishers.jwks.json)"; exit 1; }
          jq -e '.keys|length>0' .github/trust/publishers.jwks.json >/dev/null
          test -f .github/trust/allowed_signers.json || { echo "::error::allowed_signers.json missing"; exit 1; }
          test -f .github/trust/revocations.json || { echo '{"kids":[]}' > .github/trust/revocations.json; }
          if [ -n "${AWS_KMS_KEY_ID:-}" ]; then
            K="AWS:${AWS_KMS_KEY_ID}"
            jq -r '.keys[].kid' .github/trust/publishers.jwks.json | grep -Fx "$K" >/dev/null || true
          fi

      - name: Trust-store check for signer (warn/block)
        shell: bash
        env:
          ENF: ${{ env.ENFORCEMENT }} # warn / block
          AWS_KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail

          if [ -z "${AWS_KMS_KEY_ID:-}" ]; then
            echo "::warning::vars.AWS_KMS_KEY_ID is empty — signer KID check skipped"
            exit 0
          fi

          SKID="AWS:${AWS_KMS_KEY_ID}"

          ok=0
          if test -f .github/trust/publishers.jwks.json; then
            jq -e --arg k "$SKID" '.keys[]? | select(.kid == $k)' .github/trust/publishers.jwks.json >/dev/null && ok=1 || true
          fi

          revoked=0
          if test -f .github/trust/revocations.json; then
            jq -e --arg k "$SKID" '.kids[]? | select(. == $k)' .github/trust/revocations.json >/dev/null && revoked=1 || true
          fi

          if [ "$ok" -ne 1 ]; then
            echo "::warning::Signer $SKID is NOT in .github/trust/publishers.jwks.json"
            if [ "${ENF:-warn}" = "block" ]; then
              echo "::error::Enforcement=block → failing"
              exit 1
            fi
          fi

          if [ "$revoked" -eq 1 ]; then
            echo "::warning::Signer $SKID is REVOKED in .github/trust/revocations.json"
            if [ "${ENF:-warn}" = "block" ]; then
              echo "::error::Enforcement=block → failing"
              exit 1
            fi
          fi

          echo "Trust-store signer check complete: ok=$ok revoked=$revoked skid=$SKID"

  access_recert_gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Block if any group recert is expired
        shell: bash
        run: |
          set -euo pipefail
          test -f .github/trust/access_catalog.json || { echo "::error::missing .github/trust/access_catalog.json"; exit 1; }
          NOW=$(date -u +%F)
          EXPIRED=$(jq -r --arg NOW "$NOW" '.groups[] | select(.recert_expires_at < $NOW) | .name' .github/trust/access_catalog.json)
          if [ -n "$EXPIRED" ]; then
            echo "::error::Access recert expired for groups:"
            echo "$EXPIRED" | sed 's/^/- /'
            exit 1
          fi

  kms_sign_and_verify:
    needs: [build_and_attest, trust_store_guard]
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      id-token: write
      contents: read
    env:
      AWS_ALLOWED: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/release' || startsWith(github.ref, 'refs/heads/release/') || startsWith(github.ref, 'refs/tags/v') }}
    steps:
      - name: (light) egress log
        shell: bash
        run: |
          echo "Open connections BEFORE:"; ss -tpn || true

      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Load org trust-store (for this job too)
        if: env.AWS_ALLOWED == 'true'
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          if [ -n "${ORG_TRUST_REPO:-}" ] && gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
            test -d _orgtrust/.github/trust && cp -a _orgtrust/.github/trust/. .github/trust/ || true
          fi

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build

      - name: Configure AWS (OIDC assume role)
        if: env.AWS_ALLOWED == 'true'
        uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
          audience: sts.amazonaws.com
          role-session-name: gha-${{ github.run_id }}-${{ github.run_attempt }}

      - name: KMS Sign artifact.txt (PS256)
        if: env.AWS_ALLOWED == 'true'
        run: |
          set -euo pipefail
          aws kms sign --key-id "${{ vars.AWS_KMS_KEY_ID }}" \
            --signing-algorithm RSASSA_PSS_SHA_256 --message-type RAW \
            --message fileb://artifact.txt --query Signature --output text | base64 -d > artifact.sig

      - name: Fetch public key & verify
        if: env.AWS_ALLOWED == 'true'
        run: |
          set -euo pipefail
          aws kms get-public-key --key-id "${{ vars.AWS_KMS_KEY_ID }}" \
            --query PublicKey --output text | base64 -d > aws-pub.der
          openssl pkey -pubin -inform DER -in aws-pub.der -out aws-pub.pem
          openssl dgst -sha256 -verify aws-pub.pem -signature artifact.sig \
            -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:digest -sigopt rsa_mgf1_md:sha256 artifact.txt

      - name: Checking access to AWS. If access is available, this step is skipped.
        if: env.AWS_ALLOWED != 'true'
        run: echo "::notice::Skipping AWS assume/sign (ref '${GITHUB_REF}' is not main/release/*/tags v*)"

      - name: Save signing evidence
        if: env.AWS_ALLOWED == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: signing-evidence
          path: |
            artifact.txt
            artifact.sig
            aws-pub.pem
            checksums.txt
  
  allowed_signers_gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Load org trust-store (if set)
        id: t
        shell: bash
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          SRC=""
          if [ -n "${ORG_TRUST_REPO:-}" ]; then
            if gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
              if [ -d _orgtrust/.github/trust ]; then
                cp -a _orgtrust/.github/trust/. .github/trust/
                SRC="org:${ORG_TRUST_REPO}"
              fi
            else
              echo "::notice::gh clone failed (private repo or GH_TOKEN missing?)"
            fi
          fi
          if [ -z "$SRC" ] && [ -d ".github/trust" ]; then
          SRC="local:.github/trust (already present)"
          fi
          echo "source=${SRC:-none}" >> "$GITHUB_OUTPUT"
          ls -la .github/trust || true

      - name: Allowed signers gate
        shell: bash
        env:
          TRUST_DIR: .github/trust
          KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
          WF_FILE: .github/workflows/policy.yml
        run: |
          set -euo pipefail

          test -f "$TRUST_DIR/publishers.jwks.json" || { echo "::error::missing publishers.jwks.json"; exit 1; }
          test -f "$TRUST_DIR/allowed_signers.json" || { echo "::error::missing allowed_signers.json"; exit 1; }
          [ -f "$TRUST_DIR/revocations.json" ] || echo '{"kids":[]}' > "$TRUST_DIR/revocations.json"

          if [ -n "${KMS_KEY_ID:-}" ]; then
            KID="AWS:${KMS_KEY_ID}"
            if ! jq -e --arg k "$KID" '.keys[]? | select(.kid == $k)' "$TRUST_DIR/publishers.jwks.json" >/dev/null; then
              echo "::warning::unknown signer $KID (org trust-store)"
              exit 1
            fi
            if jq -e --arg k "$KID" '.kids[]? | select(. == $k)' "$TRUST_DIR/revocations.json" >/dev/null; then
              echo "::warning::signer $KID revoked"
              exit 1
            fi
          fi

          PRJ="${GITHUB_REPOSITORY}"
          if ! jq -r '.[]?' "$TRUST_DIR/allowed_signers.json" | grep -Fx "$PRJ/$WF_FILE" >/dev/null; then
            echo "::warning::$PRJ/$WF_FILE not allowed in allowed_signers.json (org trust-store)"
            exit 1
          fi

          echo "allowed_signers gate OK"


  sbom_enforce:
    needs: [build_and_attest]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build
      - name: Enforce SBOM digest (FAIL on mismatch)
        shell: bash
        run: |
          set -euo pipefail
          A=$(sha256sum artifact.txt | awk '{print $1}')
          S=$(jq -r '.files[]?|select(.fileName=="artifact.txt")|.checksums[]?|select(.algorithm=="SHA256")|.checksumValue' sbom.spdx.json | head -n1)
          if [ -z "$S" ] || [ "$A" != "$S" ]; then
            echo "::error::SBOM mismatch/missing (artifact=$A, sbom=${S:-<none>})"
            exit 1
          fi

  secrets_presence_gate:
    needs: [build_and_attest]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Scan repo & workflows for secrets (heuristic)
        id: repo_scan
        shell: bash
        run: |
          set -euo pipefail
          PATTERN='AKIA|ASIA|ghp_[A-Za-z0-9]{36,}|github_pat_[A-Za-z0-9_]{82,}|xox[abrs]-|BEGIN (RSA |OPENSSH )?PRIVATE KEY|SECRET_ACCESS_KEY|token=|password='
          found=0
          grep -RInE "$PATTERN" -- . --exclude-dir=.git || true
          [ ${PIPESTATUS[0]} -eq 0 ] && found=1
          if [ -d .github/workflows ]; then
            grep -RInE "$PATTERN" -- .github/workflows --exclude-dir=.git || true
            [ ${PIPESTATUS[0]} -eq 0 ] && found=1
          fi
          echo "found=$found" >> "$GITHUB_OUTPUT"
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          path: _scan/artifacts
          merge-multiple: true
        continue-on-error: true
      - name: Scan artifacts for secrets (if present)
        id: art_scan
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d "_scan/artifacts" ] || ! ls -A _scan/artifacts >/dev/null 2>&1; then
            echo "found=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          PATTERN='AKIA|ASIA|ghp_[A-Za-z0-9]{36,}|github_pat_[A-Za-z0-9_]{82,}|xox[abrs]-|BEGIN (RSA |OPENSSH )? PRIVATE KEY|SECRET_ACCESS_KEY|token=|password='
          if grep -RInE --binary-files=without-match --exclude-dir=.git --exclude-dir=.github "$PATTERN" _scan/artifacts ; then
            echo "found=1" >> "$GITHUB_OUTPUT"
          else
            echo "found=0" >> "$GITHUB_OUTPUT"
          fi
      - name: Write secrets scan report (repo + artifacts)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p _reports
          {
            echo "# Secrets scan (repo/workflows)"
            PATTERN='AKIA|ASIA|ghp_[A-Za-z0-9]{36,}|github_pat_[A-Za-z0-9_]{82,}|xox[abrs]-|BEGIN (RSA |OPENSSH )?PRIVATE KEY|SECRET_ACCESS_KEY|token=|password='
            grep -RInE "$PATTERN" -- . --exclude-dir=.git || true
            echo
            echo "# Secrets scan (artifacts)"
            if [ -d "_scan/artifacts" ] && ls -A _scan/artifacts >/dev/null 2>&1; then
              grep -RInE --binary-files=without-match --exclude-dir=.git --exclude-dir=.github "$PATTERN" _scan/artifacts || true
            else
              echo "no artifacts to scan"
            fi
          } > _reports/secrets_scan.txt
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: security-reports
          path: _reports/secrets_scan.txt
          if-no-files-found: ignore

  permissions_gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Lint permissions (deny dangerous writes)
        run: |
          set -euo pipefail
          bad=$(grep -RInE 'permissions:\s*(write-all|{[^}]*: *write[^}]*})' .github/workflows || true)
          if [ -n "$bad" ]; then
            echo "::warning::dangerous token permissions found"
          fi
      - name: Deny interactive signing patterns
        shell: bash
        run: |
          set -euo pipefail
          bad=$(grep -RInE '\bgpg(\.exe)?\b.*\b(--sign|-s)\b|openssl .* -passin +(pass:|env:|file:|-)|ssh-keygen .* -P( |$)' -- . ':!**/.git/**' 2>/dev/null || true)
          if [ -n "$bad" ]; then
            echo "::error::interactive signing patterns found"
            echo "$bad"
            exit 1
          fi

  audit_streaming_guard:
    if: ${{ vars.AUDIT_BUCKET != '' && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository) }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AUDIT_BUCKET: ${{ vars.AUDIT_BUCKET }}
      MIN_AUDIT_RETENTION_DAYS: ${{ vars.MIN_AUDIT_RETENTION_DAYS }}
      AUDIT_MAX_OBJECTS: ${{ vars.AUDIT_MAX_OBJECTS }}
      AUDIT_SAMPLE_OBJECTS: ${{ vars.AUDIT_SAMPLE_OBJECTS }}
    steps:
      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
          audience: sts.amazonaws.com
          role-session-name: gha-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Check bucket exists
        env:
          B: ${{ env.AUDIT_BUCKET }}
        shell: bash
        run: |
          set -euo pipefail
          aws s3api head-bucket --bucket "$B" || { echo "::error::Bucket $B not found"; exit 1; }
          region="$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text 2>/dev/null || echo '')"
          [ "$region" = "None" ] && region="us-east-1"
          jq -n \
            --arg arn "arn:aws:s3:::${B}" \
            --arg region "$region" \
            --argjson ap false \
            '{BucketArn:$arn, BucketRegion:$region, AccessPointAlias:$ap}'

      - name: Lifecycle retention ≥30d
        env:
          B: ${{ env.AUDIT_BUCKET }}
        shell: bash
        run: |
          set -euo pipefail
          MIN="${MIN_AUDIT_RETENTION_DAYS:-30}"
          MIN="${MIN:-30}"
          days=0
          ol="$(aws s3api get-object-lock-configuration --bucket "$B" 2>/dev/null || true)"
          if [ -n "${ol:-}" ] && echo "$ol" | jq -e '.ObjectLockConfiguration.ObjectLockEnabled=="Enabled"' >/dev/null 2>&1; then
            d="$(echo "$ol" | jq -r '(.ObjectLockConfiguration.Rule.DefaultRetention.Days // 0) | tonumber' 2>/dev/null || echo 0)"
            y="$(echo "$ol" | jq -r '(.ObjectLockConfiguration.Rule.DefaultRetention.Years // 0) | tonumber' 2>/dev/null || echo 0)"
            days=$(( d + (y * 365) ))
          fi
          if [ "${days:-0}" -le 0 ]; then
            lc="$(aws s3api get-bucket-lifecycle-configuration --bucket "$B" 2>/dev/null || echo '')"
            days="$(jq -r '
              [
                .Rules[]? | (
                  (.Expiration.Days // 0),
                  (.NoncurrentVersionExpiration.NoncurrentDays // 0)
                )
              ] | max // 0
            ' <<<"$lc" 2>/dev/null || echo 0)"
          fi
          if [ "${days:-0}" -lt "${MIN:-30}" ]; then
            msg="Retention too low (${days}d) for bucket $B (min=${MIN}d)"
            if [ "${ENFORCEMENT:-warn}" = "block" ]; then
              echo "::error::$msg"
              exit 1
            else
              echo "::warning::$msg"
            fi
          else
            echo "Retention OK (${days}d)"
          fi

      - name: Lifecycle retention ≥ 90d
        env:
          B: ${{ env.AUDIT_BUCKET }}
        shell: bash
        run: |
          set -euo pipefail
          MIN=90
          days=0
          ol="$(aws s3api get-object-lock-configuration --bucket "$B" 2>/dev/null || true)"
          if [ -n "${ol:-}" ] && echo "$ol" | jq -e '.ObjectLockConfiguration.ObjectLockEnabled=="Enabled"' >/dev/null 2>&1; then
            d="$(echo "$ol" | jq -r '(.ObjectLockConfiguration.Rule.DefaultRetention.Days // 0) | tonumber' 2>/dev/null || echo 0)"
            y="$(echo "$ol" | jq -r '(.ObjectLockConfiguration.Rule.DefaultRetention.Years // 0) | tonumber' 2>/dev/null || echo 0)"
            days=$(( d + (y * 365) ))
          fi
          if [ "${days:-0}" -le 0 ]; then
            lc="$(aws s3api get-bucket-lifecycle-configuration --bucket "$B" 2>/dev/null || echo '')"
            days="$(jq -r '
              [
                .Rules[]? | (
                  (.Expiration.Days // 0),
                  (.NoncurrentVersionExpiration.NoncurrentDays // 0)
                )
              ] | max // 0
            ' <<<"$lc" 2>/dev/null || echo 0)"
          fi
          if [ "${days:-0}" -lt "${MIN:-90}" ]; then
            msg="No lifecycle expiration >=90d on $B (days=${days:-0})"
            if [ "${ENFORCEMENT:-warn}" = "block" ]; then
              echo "::error::$msg"
              exit 1
            else
              echo "::warning::$msg"
            fi
          else
            echo "Retention OK (${days}d)"
          fi

      - name: Saw audit objects in last 7d
        env:
          B: ${{ env.AUDIT_BUCKET }}
        shell: bash
        run: |
          set -euo pipefail
          ok=0
          for i in $(seq 0 6); do
            p="$(date -u -d "-${i} day" +%Y/%m/%d)/"
            c="$(aws s3api list-objects-v2 --bucket "$B" --prefix "$p" --max-keys 1 --query 'KeyCount' --output text 2>/dev/null || echo 0)"
            if [ "${c:-0}" -gt 0 ]; then
              ok=1
              break
            fi
          done
          if [ "$ok" -eq 1 ]; then
            echo "Saw audit objects in last 7d"
          else
            echo "::warning::No audit objects found in last 7d in $B"
          fi

      - name: Summarize recent audit objects (CI/CD categories)
        env:
          B: ${{ env.AUDIT_BUCKET }}
        shell: bash
        run: |
          set -euo pipefail
          MAX="${AUDIT_MAX_OBJECTS:-2000}"
          MAX="${MAX:-2000}"
          SAMPLE="${AUDIT_SAMPLE_OBJECTS:-200}"
          SAMPLE="${SAMPLE:-200}"

          keys_json="$(aws s3api list-objects-v2 --bucket "$B" --max-items "$MAX" --query 'Contents[].[Key,LastModified]' --output json 2>/dev/null || echo '[]')"
          [ "$(jq -r 'length' <<<"$keys_json")" -gt 0 ] || { echo "::notice::No objects found in $B"; exit 0; }

          prefix="$(jq -r 'sort_by(.[1]) | last | .[0] | capture("^(?<p>.*\\/)[^\\/]+$").p // ""' <<<"$keys_json" 2>/dev/null || echo '')"
          if [ -z "$prefix" ]; then
            prefix=""
          fi

          objs="$(aws s3api list-objects-v2 --bucket "$B" --prefix "$prefix" --max-items "$SAMPLE" --query 'Contents[].Key' --output json 2>/dev/null || echo '[]')"
          n="$(jq -r 'length' <<<"$objs")"
          [ "$n" -gt 0 ] || { echo "::notice::No objects under prefix '$prefix'"; exit 0; }

          tmp="$(mktemp -d)"
          trap 'rm -rf "$tmp"' EXIT

          count_total=0
          declare -A cat
          cat[workflows]=0
          cat[artifact]=0
          cat[repo]=0
          cat[checks]=0
          cat[environment]=0
          cat[other]=0

          i=0
          while [ "$i" -lt "$n" ]; do
            k="$(jq -r ".[$i]" <<<"$objs")"
            aws s3 cp "s3://$B/$k" "$tmp/obj.json" >/dev/null 2>&1 || { i=$((i+1)); continue; }
            a="$(jq -r '(.action // .eventName // "")' "$tmp/obj.json" 2>/dev/null || echo '')"
            if [ -n "$a" ]; then
              count_total=$((count_total+1))
              if echo "$a" | grep -Eiq '(workflow|actions)'; then
                cat[workflows]=$((cat[workflows]+1))
              elif echo "$a" | grep -Eiq '(artifact)'; then
                cat[artifact]=$((cat[artifact]+1))
              elif echo "$a" | grep -Eiq '(repo|repository|branch|tag)'; then
                cat[repo]=$((cat[repo]+1))
              elif echo "$a" | grep -Eiq '(check|status)'; then
                cat[checks]=$((cat[checks]+1))
              elif echo "$a" | grep -Eiq '(environment|deployment)'; then
                cat[environment]=$((cat[environment]+1))
              else
                cat[other]=$((cat[other]+1))
              fi
            fi
            i=$((i+1))
          done

          echo "Found ${count_total} CI/CD audit events (workflows/artifact/repo/checks/environment)."
          jq -n \
            --arg bucket "$B" \
            --arg prefix "$prefix" \
            --argjson total "$count_total" \
            --argjson workflows "${cat[workflows]}" \
            --argjson artifact "${cat[artifact]}" \
            --argjson repo "${cat[repo]}" \
            --argjson checks "${cat[checks]}" \
            --argjson environment "${cat[environment]}" \
            --argjson other "${cat[other]}" \
            '{bucket:$bucket,prefix:$prefix,total:$total,workflows:$workflows,artifact:$artifact,repo:$repo,checks:$checks,environment:$environment,other:$other}'

  rerun_guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Block rerun without explicit approval (PR only)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          ATTEMPT: ${{ github.run_attempt }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if [ "${ATTEMPT:-1}" -gt 1 ]; then
            pr=$(jq -r .number "$GITHUB_EVENT_PATH")
            labels=$(gh pr view "$pr" --json labels -q '.labels[].name' | tr '\n' ' ')
            echo "$labels" | grep -q 'Re-Run-Approved'
          fi

  prod_release_gate:
    needs: [access_recert_gate, build_and_attest, trust_store_guard, kms_sign_and_verify, sbom_enforce, verify_action_publishers]
    if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Load org trust-store (required in this job)
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          SRC=""
          if [ -n "${ORG_TRUST_REPO:-}" ]; then
            if gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q; then
              if [ -d _orgtrust/.github/trust ]; then
                cp -a _orgtrust/.github/trust/. .github/trust/
                SRC="org:${ORG_TRUST_REPO}"
              fi
            else
              echo "::notice::gh clone failed (private repo or ORG_READ_TOKEN missing?)"
            fi
          fi
          if [ -z "$SRC" ] && [ -f ".github/trust/publishers.jwks.json" ]; then
            SRC="local:.github/trust"
          fi
          if [ ! -f ".github/trust/publishers.jwks.json" ]; then
            echo "::error::missing .github/trust/publishers.jwks.json. Set repo var ORG_TRUST_REPO and secret ORG_READ_TOKEN, or commit .github/trust/*."
            exit 1
          fi
          test -f .github/trust/allowed_signers.json || { echo "::error::missing .github/trust/allowed_signers.json"; exit 1; }
          test -f .github/trust/revocations.json || echo '{"kids":[]}' > .github/trust/revocations.json
          jq -e '.keys|length>0' .github/trust/publishers.jwks.json >/dev/null

      - name: Enforce release-only refs
        shell: bash
        run: |
          set -euo pipefail
          case "${GITHUB_REF}" in refs/heads/main|refs/heads/release/*|refs/tags/v*) ;; *)
            echo "::error::Deploy allowed only from main/release/*/v*"; exit 1;;
          esac

      - name: Check key revocations (warn/block)
        shell: bash
        env:
          ENF: ${{ env.ENFORCEMENT }}
          AWS_KMS_KEY_ARN: ${{ vars.AWS_KMS_KEY_ARN }}
          AWS_KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          if [ -n "${AWS_KMS_KEY_ARN:-}" ]; then
            KID="AWS:${AWS_KMS_KEY_ARN}"
          elif [ -n "${AWS_KMS_KEY_ID:-}" ]; then
            KID="AWS:${AWS_KMS_KEY_ID}"
          else
            echo "::warning::No AWS_KMS_KEY_ARN/AWS_KMS_KEY_ID set -> skipping revocation check"
            exit 0
          fi

          if jq -r '.kids[]?' .github/trust/revocations.json | grep -Fxq "$KID"; then
            msg="Key revoked ($KID)"
            if [ "${ENF:-warn}" = "block" ]; then
              echo "::error::$msg"
              exit 1
            else
              echo "::warning::$msg"
            fi
          else
            echo "KID not revoked"
          fi

      - name: Enforce signer present in JWKS (unknown -> block)
        shell: bash
        env:
          AWS_KMS_KEY_ARN: ${{ vars.AWS_KMS_KEY_ARN }}
          AWS_KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          if [ -n "${AWS_KMS_KEY_ARN:-}" ]; then
            KID="AWS:${AWS_KMS_KEY_ARN}"
          elif [ -n "${AWS_KMS_KEY_ID:-}" ]; then
            KID="AWS:${AWS_KMS_KEY_ID}"
          else
            echo "::error::No AWS_KMS_KEY_ARN/AWS_KMS_KEY_ID set"
            exit 1
          fi

          jq -e --arg k "$KID" '.keys[]? | select(.kid == $k)' .github/trust/publishers.jwks.json >/dev/null \
            || { echo "::error::unknown signer $KID (not in .github/trust/publishers.jwks.json)"; exit 1; }

      - name: Verify OIDC claims + allowed_signers (warn/block)
        shell: bash
        env:
          ENF: ${{ env.ENFORCEMENT }}
          EXPECT_REPO: ${{ github.repository }}
          EXPECT_WF: ${{ github.workflow_ref }}
        run: |
          set -euo pipefail

          url="${ACTIONS_ID_TOKEN_REQUEST_URL:-}"
          tok="${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}"
          if [ -z "$url" ] || [ -z "$tok" ]; then
            echo "::error::OIDC env vars missing (need permissions: id-token: write)"
            exit 1
          fi

          jwt="$(curl -fsSL -H "Authorization: Bearer $tok" "${url}&audience=sts.amazonaws.com" | jq -r '.value')"
          [ -n "$jwt" ] && [ "$jwt" != "null" ] || { echo "::error::failed to fetch OIDC token"; exit 1; }

          payload_b64="$(echo "$jwt" | cut -d. -f2)"
          payload_json="$(python3 -c 'import sys,base64; b=sys.stdin.read().strip(); b+="="*(-len(b)%4); print(base64.urlsafe_b64decode(b).decode("utf-8"))' <<<"$payload_b64")"

          repo_claim="$(echo "$payload_json" | jq -r '.repository // empty')"
          ref_claim="$(echo "$payload_json" | jq -r '.ref // empty')"
          wf_claim="$(echo "$payload_json" | jq -r '.job_workflow_ref // empty')"

          if [ -n "$repo_claim" ] && [ "$repo_claim" != "$EXPECT_REPO" ]; then
            echo "::error::OIDC repo mismatch (claim=$repo_claim expected=$EXPECT_REPO)"
            exit 1
          fi

          if [ -n "$ref_claim" ] && ! echo "$ref_claim" | grep -Eq '^refs/(heads/(main|release/.*)|tags/v.*)$'; then
            echo "::error::OIDC ref not allowed (claim=$ref_claim)"
            exit 1
          fi

          wf="${wf_claim:-$EXPECT_WF}"
          if ! jq -r '.[]?' .github/trust/allowed_signers.json | grep -Fxq "$wf"; then
            msg="workflow not in allowed_signers (wf=$wf)"
            if [ "${ENF:-warn}" = "block" ]; then
              echo "::error::$msg"
              exit 1
            else
              echo "::warning::$msg"
            fi
          else
            echo "workflow allowed"
          fi


  promote_to_prod:
    needs: [prod_release_gate, kms_sign_and_verify, build_and_attest]
    runs-on: ubuntu-latest
    environment:
      name: production
    concurrency:
      group: deploy-${{ github.ref_name }}
    steps:
      - run: echo "All upstream gates passed. Waiting for env approval…"

  rollback_to_prod:
    if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    needs: [prod_release_gate, access_recert_gate]
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - run: echo "Manual rollback to production requested. Waiting for environment approval..."

  secrets_kms_admin:
    needs: [access_recert_gate]
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: admin-ops
    steps:
      - run: echo "Admin operation on secrets/KMS. Waiting for environment approval..."

  rbac_admin:
    needs: [access_recert_gate]
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: admin-ops
    steps:
      - run: echo "Admin operation on RBAC/permissions. Waiting for environment approval..."

  trust_runners_admin:
    needs: [access_recert_gate]
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: admin-ops
    steps:
      - run: echo "Admin operation on trusted/registration runners. Waiting for environment approval..."

  trust_store_rotate:
    if: ${{ vars.ORG_TRUST_REPO != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Pull org trust-store
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
          GH_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        run: |
          set -euo pipefail
          rm -rf _orgtrust
          gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q
          test -d _orgtrust/.github/trust || exit 0
          mkdir -p .github/trust
          cp -a _orgtrust/.github/trust/. .github/trust/
      - name: Detect changes
        id: diff
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          BR="chore/rotate-trust-store-$(date -u +%Y%m%d%H%M%S)"
          git checkout -b "$BR"
          git add .github/trust
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            git commit -m "chore(trust-store): sync from ${{ vars.ORG_TRUST_REPO }}"
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "branch=$BR" >> "$GITHUB_OUTPUT"
          fi
      - name: Open PR
        if: steps.diff.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh pr create \
            --title "chore(trust-store): sync org trust-store" \
            --body "Automated sync of .github/trust from \`${{ vars.ORG_TRUST_REPO }}\`" \
            --base "main" || true

  presence_gate:
    needs: [codeql, dependency_review, secrets_presence_gate]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    permissions:
      contents: read
      pull-requests: read
      security-events: read
    steps:
      - name: Require SAST/SCA/Secrets to have RUN (skip ⇒ WARN)
        shell: bash
        run: |
          set -euo pipefail
          SAST="${{ needs.codeql.result }}"
          SCA="${{ needs.dependency_review.result }}"
          SECR="${{ needs.secrets_presence_gate.result }}"
          warn=0
          for n in "SAST:$SAST" "SCA:$SCA" "SECRETS:$SECR"; do
            v="${n##*:}"
            if [ "$v" = "skipped" ] || [ "$v" = "cancelled" ]; then
              warn=1
            fi
          done
          [ $warn -eq 0 ] || true
      - name: Baseline governance (changes require review)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          pr=$(jq -r .number "$GITHUB_EVENT_PATH")
          repo="${GITHUB_REPOSITORY}"
          PATTERN='^(\.github/security-baselines/|\.codeql/|baseline/|secrets\.allowlist|trivy\.ignore|codeql\.sarif)$'
          changed=$(gh api repos/$repo/pulls/$pr/files --paginate -q '.[].filename' | tr -d '\r' || true)
          echo "$changed" | grep -E "$PATTERN" >/dev/null 2>&1 || exit 0
          has_label=$(gh pr view "$pr" --repo "$repo" --json labels -q '[.labels[]?.name] | index("Baseline-Reviewed") != null')
          has_reason=$(gh pr view "$pr" --repo "$repo" --json body -q '(.body // "") | test("(?i)(baseline|suppression|обосн|подавлен|reason)")')
          if [ "$has_label" != "true" ] && [ "$has_reason" != "true" ]; then
            echo "::error::Baseline changes detected; add label 'Baseline-Reviewed' or put rationale in PR description"
            exit 1
          fi

  collect_security_reports:
    needs: [presence_gate]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    permissions:
      contents: read
      security-events: read
      pull-requests: read
    steps:
      - name: Gather reports
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p _reports
          repo="${GITHUB_REPOSITORY}"
          gh api repos/$repo/code-scanning/alerts --paginate > _reports/codeql_alerts.json || echo '[]' > _reports/codeql_alerts.json
          gh api repos/$repo/dependabot/alerts --paginate > _reports/dependabot_alerts.json || echo '[]' > _reports/dependabot_alerts.json
          jq -n --arg SAST "${{ needs.codeql.result }}" \
                --arg SCA  "${{ needs.dependency_review.result }}" \
                --arg SECR "${{ needs.secrets_presence_gate.result }}" \
                '{sast:$SAST, sca:$SCA, secrets:$SECR}' > _reports/presence.json
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: security-reports
          path: _reports
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: security-reports
          path: _reports/*
          overwrite: true

  release_protection:
    if: ${{ startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Block if release already exists for this tag
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag="${GITHUB_REF#refs/tags/}"
          if gh release view "$tag" >/dev/null 2>&1; then
            echo "::error::Release ${tag} already exists — publishing over release is forbidden"
            exit 1
          fi

  attach_security_reports:
    needs: [collect_security_reports, release_protection]
    if: ${{ startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      security-events: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: security-reports
          path: reports
          overwrite: true
      - name: Upload reports to Release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${GITHUB_REF#refs/tags/}"
          gh release view "$tag" >/dev/null 2>&1 || gh release create "$tag" -t "$tag" -n "Automated release"
          gh release upload "$tag" reports/* --clobber || true

  audit_ci_changes:
    name: M2 — Audit workflow/plugins & exfil (enterprise-safe)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
        with:
          fetch-depth: 0

      - name: Compute changed files (no external actions)
        id: cf
        shell: bash
        run: |
          set -euo pipefail
          get_changed() {
            if [ "${GITHUB_EVENT_NAME}" = "pull_request" ]; then
              base=$(jq -r .pull_request.base.sha "$GITHUB_EVENT_PATH")
              head="${GITHUB_SHA}"
              git fetch --no-tags --prune --depth=1 origin "$base" >/dev/null 2>&1 || true
              git diff --name-only "$base" "$head"
            else
              before=$(jq -r '.before // empty' "$GITHUB_EVENT_PATH")
              if [ -n "$before" ] && [ "$before" != "0000000000000000000000000000000000000000" ]; then
                git diff --name-only "$before" "$GITHUB_SHA"
              else
                git fetch --no-tags --prune --depth=2 origin "${GITHUB_REF}" >/dev/null 2>&1 || true
                git diff --name-only "${GITHUB_SHA}^" "$GITHUB_SHA" 2>/dev/null || true
              fi
            fi
          }
          CHANGED="$(get_changed | tr -d '\r' | sed 's|^\./||')"
          echo "all_changed_files<<__EOF__" >> "$GITHUB_OUTPUT"
          echo "$CHANGED" >> "$GITHUB_OUTPUT"
          echo "__EOF__" >> "$GITHUB_OUTPUT"
          if printf '%s\n' "$CHANGED" | grep -E '^\.?github/workflows/.*\.ya?ml$' >/dev/null; then
            echo "any_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "any_changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Validate action owners + pin to full SHA (WARN only)
        if: steps.cf.outputs.any_changed == 'true'
        shell: bash
        env:
          ALLOW_OWNERS: actions|github|aws-actions|google-github-actions|dependabot|azure
        run: |
          set -euo pipefail
          status=0
          while IFS= read -r f; do
            [ -n "$f" ] || continue
            mapfile -t USES < <(awk '/uses:/{print $0}' "$f" | sed -E 's/^[[:space:]-]*uses:[[:space:]]*//')
            for u in "${USES[@]}"; do
              owner=$(echo "$u" | awk -F'[/:@]' '{print $1}')
              ref=$(echo "$u" | awk -F'@' '{print $2}')
              if ! [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
                status=1
              fi
              if ! [[ "$owner" =~ ^(${ALLOW_OWNERS})$ ]]; then
                status=1
              fi
            done
          done < <(printf '%s\n' "${{ steps.cf.outputs.all_changed_files }}" | grep -E '^\.?github/workflows/.*\.ya?ml$' || true)
          [ $status -eq 0 ] || true

      - name: actionlint (download binary, WARN only)
        if: steps.cf.outputs.any_changed == 'true'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          ver="1.7.1"
          url="https://github.com/rhysd/actionlint/releases/download/v${ver}/actionlint_${ver}_linux_amd64.tar.gz"
          curl -fsSL "$url" -o /tmp/actionlint.tgz
          tar -xzf /tmp/actionlint.tgz -C /tmp actionlint
          if ! /tmp/actionlint -color; then
            echo "::warning::actionlint reported issues"
          fi

      - name: Block artifact exfil when added
        if: steps.cf.outputs.any_changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          bad=0
          while IFS= read -r f; do
            [ -n "$f" ] || continue
            if grep -nE "upload-artifact|download-artifact" "$f"; then
              bad=1
            fi
          done < <(printf '%s\n' "${{ steps.cf.outputs.all_changed_files }}" | grep -E '^\.?github/workflows/.*\.ya?ml$' || true)
          [ $bad -eq 0 ] || true
